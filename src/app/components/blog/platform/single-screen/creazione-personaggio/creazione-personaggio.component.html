<section class="hero is-primary">
  <div class="hero-body">
    <div class="container">
      <h1 class="title">
        Platform game: inizializziamo
      </h1>
      <h2 class="subtitle">
        Prepariamo il canvas con tutti metodi che ci servono
      </h2>
    </div>
  </div>
</section>
<section class="section">
  <div class="container">
    <div class="column is-8 is-offset-2">
      <div class="content is-medium">
        <p> Come promesso nel capitolo precedente <a routerLink="platform/inizializziamo">Iniziamo anzi
            inizializiamo</a> dove abbiamo settato il nostro canvas e
          provato qualche metodo legato a 2d, <span class="has-text-weight-bold">creeremo concretamente il nostro
            platform.</span></p>

        <section class="paragraph">
          <h2>Creazione Protagonista</h2>

          <p>Andiamo a creare il nostro protagonista, che per adesso sar√† un rettangolo ‚¨õ, ma niente paura, pi√π avanti
            lo sostituiremo con degli <span class="has-text-weight-bold">sprite</span>, che non √® la bibita gassata üçæ,
            ma
            delle <span class="has-text-weight-bold">immagini in movimento, che riprodotte
              in maniera sequenziale daranno l‚Äôidea di movimento. üö∂‚ÄçüèÉ</span></p>
          <pre><code [highlight]="varCode"></code></pre>

          <p>Abbiamo salvato le propriet√† del rettangolo in delle variabili cos√¨ da avere una maggiore leggibilit√† e
            riusabilit√† del codice. Altezza, larghezza, posizione iniziale sull‚Äôasse delle x e posizione iniziale
            sull‚Äôasse delle y. Quest‚Äôultima l‚Äôabbiamo posizionata a filo della parte inferiore del canvas. Le x e le y
            degli oggetti vengono posizionati dal loro punto di origine, il vertice in alto a sinistra. Quindi se
            proviamo a posizionarlo assegnandogli solo la fine del canvas il rettangolo sarebbe sparito sotto, mentre
            sottraendo l‚Äôaltezza il rettangolo rimane perfettamente a filo. </p>
          <p>Nella fig1 e fig2 si capisce meglio la differenza.</p>
          <figure class="image">
            <img src="https://i.ibb.co/vkXF9vC/canvas-Rect-Down.jpg" alt="la figura rimane sotto il canvas">
            <figcaption class="is-size-6">fig1 Se non calcoliamo l'alterzza, la figura finisce sotto il canvas
            </figcaption>
            <br>
            <img src="https://i.ibb.co/7bsFGcz/canvas-Rect-Up.jpg"
              alt="la figura sottratta l'altezza si appoggia al canvas">
            <figcaption class="is-size-6">fig2 La figura √® appoggiata alla fine del canvas avendole sottratto l'altezza
            </figcaption>
          </figure>
          <pre><code [highlight]="fillRectCode"></code></pre>
          <p>Disegnamo sul canvas con il metodo <span class="is-italic">fillRect</span>, che abbiamo visto nel
            precedente articolo <a routerLink="platform/inizializziamo">Iniziamo anzi
              Inizializziamo</a> e gli passiamo come parametri le variabili create pocanzi.</p>

          <br>
          <div class="canvas-containter">
            <div class="columns is-centered ">
              <app-canvas [classCanvas]="moveRectNoClear" [addBtn]="false"></app-canvas>
            </div>
            <p class="is-7 has-text-centered is-italic">Il "protagoista" disegnato sul canvas</p>
          </div>

        </section>
        <br>
        <section class="paragraph">
          <h2>Facciamolo muovere</h2>
          <p>Passiamo a muovere la nostra creatura üë∂, per fare questo dobbiamo ad ogni spostamento ridisegnare il
            rettangolo aumentando o diminuendo il valore della x se vogliamo farlo muove in orizzontale, il valore
            della y se vogliamo farlo muovere in verticale ed entrambi se vogliamo che si muova in diagonale.</p>
          <p>Per fare ci√≤ abbiamo bisogno <span class="has-text-weight-bold">un loop temporale che non √® altro che un
              ciclo üîÑ che ripete delle istruzioni con un intervallo di tempo.</span></p>
          <p><span class="has-text-weight-bold">Il canvas ha un suo metodo specifico per gestire questo ciclo</span>,
            molto pi√π efficiente e performante, il
            <span class="is-italic">requestAnimationFrame(NomeDellafunzioneLoop)</span>. </p>
          <p>Vediamolo subito all‚Äôopera üëÄ.</p>
          <pre><code [highlight]="loopCode"></code></pre>
          <p>La funzione nominata <span class="has-text-weight-bold"><span class="is-italic">loop()</span> sar√† il cuore
              di tutto</span>, dove metteremo tutte le azioni che il gioco dovr√†
            compiere e grazie al <span class="is-italic">requestAnimationFrame(loop)</span> richiamando <span
              class="has-text-weight-bold">la funzione ‚Äúloop‚Äù
              creer√† cos√¨ un ciclo infinito.</span>
          </p>
          <p>Il <span class="is-italic">requestAnimationFrame</span> in fondo al codice √® l‚Äôistruzione che fa da
            ‚Äústarter‚Äù üèÅ che far√† partire il gioco chiamando la funzione principale.</p>

          <p>Come abbiamo accennato precedentemente per muovere il protagonista dobbiamo ad ogni ciclo fagli fare un
            passettino nella direzione desiderata, quindi lo sposteremo verso l‚Äôasse delle x a destra di 5px.
          </p>
          <pre><code [highlight]="loopMoveTxt"></code></pre>
          <p>Con l‚Äôoperatore =+ aumentiamo di 5, il valore della variabile step, alla x del giocatore, spostandolo ad
            ogni ciclo di 5px;</p>
          <app-canvas [classCanvas]="moveRectNoClear" [addBtn]="true"></app-canvas>

          <p>Ma che succede? ü§î Invece di spostarsi il rettangolo lo allunga!
            Questo perch√© <span class="has-text-weight-bold">ad ogni ad ogni ciclo il canvas ridisegna tutti gli oggetti
              presenti.</span> Quindi il nostro
            rettangolo non viene spostato di 5px, ma ridisegnato ogni 5px, moltiplicandosi.
            Per sopperire a questo e dare l‚Äôeffetto di movimento dobbiamo fare un refresh all‚Äôinizio di ogni inizio
            ciclo, ripulendo il canvas.
          </p>
          <pre><code [highlight]="clearRectCode"></code></pre>
          <p>Con il metodo <span class="is-italic">clearRect( x, y, width, height )</span>, molto simile a fillRect, ma
            in questo caso cancelli un porzione rettangolare. Per pulire tutto lo schermo questa porzione dovr√† essere
            grande come il cavas e partire dal punto di origine x: 0, y: 0.</p>
          <app-canvas [classCanvas]="moveRect" [addBtn]="true"></app-canvas>
        </section>
        <br>
        <section class="paragraph">
          <h2>Creiamo dei confini</h2>
          <p>Il nostro personaggio per√≤ deve restare all‚Äôinterno del canvas, quindi <span
              class="has-text-weight-bold">bisogna fermarlo üö´ appena tocca i bordi.</span></p>
          <p>Quindi per non farlo uscire: </p>
          <ul>
            <li>dal lato sinistro la x del rettangolo deve essere maggiore di 0 (la x di origine del canvas)</li>
            <li>dal lato destro la somma della x pi√π la larghezza del rettangolo devono essere minori della larghezza
              del canvas.</li>
            <li>dal lato superiore la y del rettangolo deve essere maggiore di 0 (la y di origine del canvas)</li>
            <li>dal lato destro la somma della y pi√π la lunghezza del rettangolo devono essere minori della lunghezza
              del canvas.</li>
          </ul>
          <img src="" alt="">
          <pre><code [highlight]="borderCode"></code></pre>
          <p>Traduciamo il tutto in codice, SE la x √® maggiore di 0 E la x meno la larghezza del rettangolo √® minore
            della larghezza del canvas E la y √® maggiore di 0 E la y meno la lunghezza del rettangolo √® minore della
            lunghezza del canvas ALLORA fallo muovere.</p>
        </section>
        <section class="paragraph">
          <h2>Conclusione</h2>
          <p>
            In questo articolo abbiamo il nostro personaggio, che non sar√† definitivo, visto che pi√π avanti lo andreamo
            a completare con delle immagini, e lo abbiamo fatto muovere all'interno del canvas</p>
          <p><span class="has-text-weight-bold">Nel prossimo articolo prenderemo il controllo üéÆ del personaggio</span>,
            muovendolo e facendolo saltare.</p>
          <p>Se non lo avete ancora fatto <span class="has-text-weight-bold">iscrivetevi alla newsletter</span>, cos√¨ da
            assere avvisati appena arriva il prossimo
            articolo</p>
        </section>
        <br>
        <app-newsletter-block></app-newsletter-block>
        <br>
        <app-end-on-all-page-blog></app-end-on-all-page-blog>
      </div>
    </div>
    <!-- column is-8 is-offset-2 -->
  </div>
  <!-- container -->
</section>
<!-- section -->
